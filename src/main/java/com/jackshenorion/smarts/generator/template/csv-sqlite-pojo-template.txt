// THIS CODE IS GENERATED. DO NOT MODIFY IT OR YOUR CHANGES WILL BE OVERWRITTEN AT SOME POINT.
// VERSION <version>
// DATE \<date>

package <javaPackage>;

import util.shared.json.*;
import util.shared.date.*;
import util.shared.date.serializer.*;
import util.shared.primitive.*;
import util.shared.primitive.serializer.*;
import java.util.*;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.databind.annotation.*;
<if(backwardComp)>import com.fasterxml.jackson.annotation.JsonIgnoreProperties;<endif>
<javaImportPackages: { pkg |
import <pkg>.*;
}>

<if(backwardComp)>@JsonIgnoreProperties(ignoreUnknown = true)<endif>
public final class <name> <if(hasBase)>extends <javaBase><else>implements JsonSerializable<endif> {

<props: { prop |
	<prop.javaDeclaration>; <prop.comment>
}>

	public <name>() {
	}

<props: { prop |
<if(prop.isList)>
	public int count<prop.capName>() { return <prop.name>.size(); \}
	public <prop.javaType> get<prop.singularName>(int index) { return index >=0 && index \< <prop.name>.size() ? <prop.name>.get(index) : null; \}
	public List\<<prop.javaType>> <prop.getter>() { return Collections.unmodifiableList(<prop.name>); \}
	public <name> <prop.setter>(List\<<prop.javaType>> newInstances) { <prop.name>.clear(); <prop.name>.addAll(newInstances); return this; \}
    public <name> add<prop.singularName>(<prop.javaType> instance) {
        return this.add<prop.singularName>(instance, <prop.name>.size());
    \}
    public <name> add<prop.singularName>(<prop.javaType> instance, int index) {
        assert !<prop.name>.contains(instance) : "Instance already exists.";
        <prop.name>.add(index, instance);
        return this;
    \}
    public <name> remove<prop.singularName>(<prop.javaType> instance) {
        <prop.name>.remove(instance);
        return this;
    \}

<else>
	public <prop.javaType> <prop.getter>() { return <prop.name>; \}
<if(prop.hasSetter)>
	public <name> <prop.setter>(<prop.javaType> value) { this.<prop.name> = value; return this; \}
<if(prop.isPrimitive && prop.isVal)>
	@JsonIgnore public <name> <prop.setter>(<prop.javaPrimitiveType> value) { this.<prop.name> = Vals.of(value); return this; \}
<endif>

<endif>
<endif>
}>

	@Override
    public void readJson(JsonValue js) {
        <if(hasBase)>super.readJson(js);<endif>
        JsonObject jso = js.asObject();
        if (jso == null) {
            return;
        }
<props: { prop |
		<prop.javaReadJson>;
}>
    }

    @Override
    public JsonValue writeJson() {
        return <if(hasBase)>super.writeJson().asObject()<else>JsonObject.create()<endif>
<props: { prop |
		    <prop.javaWriteJson>
}>
        ;
    }

}